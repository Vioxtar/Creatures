



	TODO:
	Find if theres a way to pass non-interpolated data to the fragment shader by creature instance
	Implement 'visibilities' SSBO, every frame update each creature's 'LOD' value: false is offscreen, true is visible
	Sensors
	Energy + life + actuation system
	Reproduction and mutation system
	(Optional) Refactor simulation.cpp by splitting up code (programs, creature SSBOs, etc, just like camera is split up)
	Settings pretty names
	DearImgui integration and UI
		F11 to fullscreen


	Add WINDOW settings in settings file?
	Spikes and shields and stick mechanisms
	Fix window misalignment
	FIX THE WEIRD GHOST BALL AT 0, 0






	Some notes
	
		RadiusPercentage = 0.3 * LifePercentage + 0.5 * EnergyPercentage + 0.2 * ControlPercentage

	saturation belongs to family
	life reflected by fill

	make stickyness global to creature's body, make A not stick to B if A deflects B with shield or if B deflects A with shield..?

	Creatures control hardness target, and have a stick mechanism (either arms or body or some sort of friction side)

	Sigmoid activation can be described as:

	sigmoidActivation(x) =
		if x == 0.5 then return x
		if x < 0.5 then return ((2x)^a)/2
		if x > 0.5 then return -(((2(1-x))^a) / 2) + 1

	for some constant a = 8-ish

	It could also probably be approximated further by dividing into regions and returning linear functions within those regions

















	Approach to brains:
	We wish to minimize memory complexity of brains with minimal time complexity tradeoffs.
	
	Assume that:
	1. We have about 2 GB of usage space for brains
	2. We want to support up to 100,000 creatures at once

	Some numbers:
		1 GB =~ 250,000,000 floats
		250,000,000 / 100,000 = 2500 floats per creature
		However we about just about 2 GB available, so that's 500,000,000 floats / 100,000 creatures = 5000 floats per creature.
		Going by that number, that gives us just about 4500 floats per brain, leaving us with 500*4 bytes for other attributes.
		

	Some more numbers:
		If we would have 40 nodes in a level, and up to 5 levels, then every link level would have 40^2 = 1600 links, meaning 1600*5 = 8000 total links in the brain. If every link has a scalar float and a bias float, then that's 16000 floats per brain!
		A more feasible scenario is have 60 input nodes, 10 nodes in every hidden level, and 5 levels, that means: 60*10 + 10*10*4 = 1000 links in the entire brain! 2 floats in a link implies 2000 floats, and were we to consider node values, then that's 110 more floats = 2110 floats per brain.
	
		If a sensor each has:
			1. Activation
			2. Hue
			3. Lightness
			4. Saturation
		
		And we have 8 sensors, then that's 4*8 = 32 inputs. 

	To minimize memory complexity we can take several approaches:

		a. Instead of merely defining # of nodes per level (which is always a very big number since inputs is about 40-50 nodes), define # of nodes per hidden level and # of nodes per input level, this will drastically decrease size!
		b. Instead of having every node connect to every other node in the previous layer, have it only connect to X nodes
		c. Don't use biases! Just scalars...

	The overall approach for brains:

		A single brain buffer would contain:

			[STRUCTURE HEADER UINTS | A SEQUENCE OF ALL NODES' CURRENT VALUES | A SEQUENCE OF LINKS]

		The structure header is simply a sequence of uints that tells us the structure of the brain.
			[NUMOFLEVELS = 5, 32, 15, 10, 18, 12] for example means 32 inputs, 3 middle levels (15, 10 and 18 nodes), and 12 outputs.

		The sequence of notes is merely the current values stored at each node. We know that this buffer always starts immediately after
		the structure header, and is exactly sum(structure values) indices long.

		Afterwards, a sequence of links: the length of this buffer is exactly 32*15 + 15*10 + 10*18 + 18*12 indices long.

	We can use this layout to cleverly iterate our brains and perform forward propagations.
	While this layout is borderline dynamic, we must make each total brain size fixed for proper SSBO indexing.
	We can choose one of two data layout approaches:
		
		[FIXED STRUCTURE | DYNAMIC NODES | DYNAMIC LINKS, empty space]
		(gives us more flexibility in how we forward propagate, less convenient for mutation logic)
	
	Or this:

		[FIXED STRUCTURE | FIXED NODES, empty space | FIXED LINKS, empty space]
		(gives us more comfort in mutation handling, less in forward propagations)

	We'll choose the first, since it may prove more flexible to changes in the future (no hard-coding of sub-buffer sizes)

	Finally we wish for a straight forward method to provide an upper bound on memory complexity of brains.
	

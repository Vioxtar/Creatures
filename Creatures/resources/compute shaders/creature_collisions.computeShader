#version 460 core

layout (std430, binding = 0) buffer CreaturePositions
{
	vec2 poses[];
};

layout (std430, binding = 1) buffer CreatureVelocities
{
	vec2 velos[];
};

layout (std430, binding = 2) buffer CreatureRadii
{
	float radii[];
};

layout (std430, binding = 3) buffer UniformGrid
{
	uint ugrid[];
};

layout (std430, binding = 4) buffer CreatureTiles
{
	uint tiles[];
};

layout (std430, binding = 5) buffer CreatureGeneralPurpose
{
	vec2 physicsFix[];
};

layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;


uniform uvec2 uGridDimensions;
uniform uint uIndicesInTile;

void main()
{
	uint gid = gl_GlobalInvocationID.x;

	uint gridXDim = uGridDimensions.x;
	uint gridYDim = uGridDimensions.y;	

	// Find our own tile
	uint tileIndex = tiles[gid];

	if (tileIndex == -1)
	{
		// We weren't included in the tile because it ran out of space
		return;
	}

	// Find its x,y tile indices
	uint xTileIndex = uint(mod(tileIndex, gridXDim));
	uint yTileIndex = (tileIndex - xTileIndex) / gridXDim;

	// Find the start/end x,y indices (consider uGridDimensions in case we're near edges)
	uint xStart = max(xTileIndex - 1, 0);
	uint xEnd = min(xTileIndex + 1, gridXDim - 1);
	uint yStart = max(yTileIndex - 1, 0);
	uint yEnd = min(yTileIndex + 1, gridYDim - 1);

	// Cache our own values, we don't need to access them every iteration
	vec2 aPos = poses[gid];
	float aRad = radii[gid];

	// Iterate on the uniform grid throughout start/end x,y indices
	for (uint x = xStart; x <= xEnd; x++)
	{
		for (uint y = yStart; y <= yEnd; y++)
		{
			// Find the 1D tile again
			uint tile = x + gridXDim * y;
			uint tileCountIndex = tile * uIndicesInTile;
			
			// It's ensured that creaturesInTile will not be above creature capacity since we don't
			// increase the creature counter of our tile if we don't enter it.
			// It's also probably still best to double check this here. Otherwise lastPopulatedIndex
			// will overstep its boundary and cause a memory miss, which is terrible for performance!
			uint creaturesInTile = ugrid[tileCountIndex];

			uint lastPopulatedIndex = tileCountIndex + creaturesInTile;
				
			for (uint b = tileCountIndex + 1; b <= lastPopulatedIndex; b++)
			{
				uint bGID = ugrid[b];
				
				// Only the creature with the lesser GID performs the calculations
				if (bGID <= gid)
				{
					continue;
				}

				vec2 bPos = poses[bGID];
				float bRad = radii[bGID];

				vec2 c1c2PosDiff = bPos - aPos;
				float distSquared = dot(c1c2PosDiff, c1c2PosDiff);

				if (distSquared <= 0)
				{
					continue;
				}

				float radiiSum = aRad + bRad;
				if (distSquared < radiiSum * radiiSum)
				{
					float dist = sqrt(distSquared);

					float violation = radiiSum - dist;
					float push = violation / radiiSum;
					float m1 = 1;
					float m2 = 1;
					float m1Frac = m1 / (m1 + m2);
					float m2Frac = m2 / (m1 + m2);

					vec2 c1PosSub = -c1c2PosDiff;
					vec2 c2PosSub = c1c2PosDiff;

					c1PosSub = c1PosSub * push;
					c2PosSub = c2PosSub * push;

					c1PosSub = c1PosSub * m2Frac;
					c2PosSub = c2PosSub * m1Frac;
				
					// Register the fix
					physicsFix[gid] += c1PosSub;
					physicsFix[bGID] += c2PosSub;
				}
			}
		}
	}

}
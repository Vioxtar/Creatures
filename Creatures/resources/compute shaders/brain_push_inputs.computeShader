#version 460 core

layout (std430, binding = 0) buffer CreatureBrainsStructures
{
	uint BrainsStructures[];
};

layout (std430, binding = 1) buffer CreatureBrainsNodes
{
	float BrainsNodes[];
};

layout (std430, binding = 2) buffer CreatureLives
{
	float Lives[];
};

layout (std430, binding = 1) buffer CreatureVelocities
{
	vec2 Velocities[];
};


layout (local_size_x = @LOCAL_SIZE@, local_size_y = 1, local_size_z = 1) in;

uniform uint uCreatureCount;
uniform uint uMaxNumOfStructureIndices;
uniform uint uMaxNumOfNodesInBrain;

void main()
{
	uint gid = gl_GlobalInvocationID.x;
	if (gid >= uCreatureCount)
	{
		return;
	}

	uint brainNodesStartIndex = gid * uMaxNumOfNodesInBrain;
	uint brainStructureStartIndex = gid * uMaxNumOfStructureIndices;


	uint numOfLevels = BrainsStructures[brainStructureStartIndex];
	uint numOfInputs = BrainsStructures[brainStructureStartIndex + 1];
	
	// Acquire the input nodes' values range in our brain data, we always assume there's enough room to push our inputs!
	uint firstInputNodeIndex = brainNodesStartIndex;
	uint firstNonInputNodeIndex = brainNodesStartIndex + numOfInputs;

	// For now just push in life and colors
	uint colIndex = gid * 3;
	BrainsNodes[firstInputNodeIndex] = Lives[gid];
	BrainsNodes[firstInputNodeIndex + 1] = Velocities[gid].x;
	BrainsNodes[firstInputNodeIndex + 2] = Velocities[gid].y;
	BrainsNodes[firstInputNodeIndex + 3] = (Velocities[gid].x + Velocities[gid].y) / 2.0;

}
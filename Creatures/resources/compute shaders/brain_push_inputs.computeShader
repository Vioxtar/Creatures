#version 460 core

layout (std430, binding = 0) buffer CreatureBrainsStructures
{
	uint BrainsStructures[];
};

layout (std430, binding = 1) buffer CreatureBrainsNodes
{
	float BrainsNodes[];
};

layout (std430, binding = 2) buffer CreatureLives
{
	float Lives[];
};

layout (std430, binding = 3) buffer CreatureEnergies
{
	float Energies[];
};

layout (std430, binding = 4) buffer CreatureMeats
{
	float Meats[];
};

layout (std430, binding = 5) buffer CreatureForwardDirections
{
	vec2 ForwardDirections[];
};

layout (std430, binding = 6) buffer CreatureRightDirections
{
	vec2 RightDirections[];
};

layout (std430, binding = 7) buffer CreatureVelocities
{
	vec2 Velocities[];
};

layout (std430, binding = 8) buffer CreatureAngleVelocities
{
	float AngleVelocities[];
};

layout (std430, binding = 9) buffer CreatureEyePupilSights
{
	float EyePupilSights[];
};

layout (std430, binding = 10) buffer CreatureEyeConeSights
{
	float EyeConeSights[];
};

layout (std430, binding = 11) buffer CreatureSkinPatterns
{
	vec2 SkinPatterns[];
};

layout (local_size_x = @LOCAL_SIZE@, local_size_y = 1, local_size_z = 1) in;

uniform uint uCreatureCount;

uniform uint uMaxNumOfStructureIndices;
uniform uint uMaxNumOfNodesInBrain;

uniform float uCreatureMaxEnergy;
uniform float uCreatureMaxLife;
uniform float uCreatureMaxMeat;

uniform float uCreatureMaxVelocityLength;
uniform float uCreatureMaxAngleVelocityLength;

uniform float uCreatureMaxRadius;
uniform float uCreatureMinRadius;

uniform uint uCreatureEyeNumOfPupilValues;
uniform uint uCreatureEyeNumOfConesValues;

void main()
{
	uint gid = gl_GlobalInvocationID.x;
	if (gid >= uCreatureCount)
	{
		return;
	}
	
	float life = Lives[gid];

	if (life <= 0.0)
	{
		return;
	}

	uint brainNodesStartIndex = gid * uMaxNumOfNodesInBrain;
	uint brainStructureStartIndex = gid * uMaxNumOfStructureIndices;

	uint numOfLevels = BrainsStructures[brainStructureStartIndex];
	uint numOfInputs = BrainsStructures[brainStructureStartIndex + 1];
	
	// Acquire the input nodes' values range in our brain data, we always assume there's enough room to push our inputs!
	uint firstInputNodeIndex = brainNodesStartIndex;
	uint firstNonInputNodeIndex = brainNodesStartIndex + numOfInputs;
	
	// Push values

	uint inputOffset = 0;

	// Body parameters
	BrainsNodes[firstInputNodeIndex + inputOffset] = Energies[gid] / uCreatureMaxEnergy;
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = life / uCreatureMaxLife;
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = Meats[gid] / uCreatureMaxMeat;
	inputOffset++;

	// Movements
	vec2 velocity = Velocities[gid];
	vec2 forwardDir = ForwardDirections[gid];
	vec2 rightDir = RightDirections[gid];

	float normForthBack = dot(velocity, forwardDir) / uCreatureMaxVelocityLength;
	float normRightLeft = dot(velocity, rightDir) / uCreatureMaxVelocityLength;
	
	float forward = max(normForthBack, 0);
	float backward = max(-normForthBack, 0);
	float right = max(normRightLeft, 0);
	float left = max(-normRightLeft, 0);

	BrainsNodes[firstInputNodeIndex + inputOffset] = forward;
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = backward;
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = right;
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = left;
	inputOffset++;

	// Angle movements
	float angleVelocityNorm = AngleVelocities[gid] / uCreatureMaxAngleVelocityLength;

	float clockwise = max(angleVelocityNorm, 0);
	float antiClockwise = max(-angleVelocityNorm, 0);

	BrainsNodes[firstInputNodeIndex + inputOffset] = clockwise;
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = antiClockwise;
	inputOffset++;

	// Eye pupil sights (normalize as needed)
	uint pupilSightStartIndex = gid * uCreatureEyeNumOfPupilValues;

	BrainsNodes[firstInputNodeIndex + inputOffset] = EyePupilSights[pupilSightStartIndex + 0]; // Activation
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = EyePupilSights[pupilSightStartIndex + 1]; // Shield prominence
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = EyePupilSights[pupilSightStartIndex + 2]; // Spike prominence
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = EyePupilSights[pupilSightStartIndex + 3]; // Feeder prominence
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = EyePupilSights[pupilSightStartIndex + 4]; // Forward aim prominence
	inputOffset++;

	BrainsNodes[firstInputNodeIndex + inputOffset] = EyePupilSights[pupilSightStartIndex + 5]; // Skin hue difference
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = EyePupilSights[pupilSightStartIndex + 6]; // Skin value
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = EyePupilSights[pupilSightStartIndex + 7]; // Skin saturation
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = EyePupilSights[pupilSightStartIndex + 8]; // Skin pattern difference
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = EyePupilSights[pupilSightStartIndex + 9] / uCreatureMaxLife; // Life
	inputOffset++;
	BrainsNodes[firstInputNodeIndex + inputOffset] = EyePupilSights[pupilSightStartIndex + 10] / uCreatureMaxEnergy; // Energy
	inputOffset++;
	
	float pupilRadius = EyePupilSights[pupilSightStartIndex + 11];
	float pupilRadiusNorm = (pupilRadius - uCreatureMinRadius) / (uCreatureMaxRadius - uCreatureMinRadius);
	BrainsNodes[firstInputNodeIndex + inputOffset] = pupilRadiusNorm; // Radius
	inputOffset++;

	// Eye cone sights
	uint conesSightStartIndex = gid * uCreatureEyeNumOfConesValues;
	for (uint i = 0; i < uCreatureEyeNumOfConesValues; ++i)
	{
		BrainsNodes[firstInputNodeIndex + inputOffset] = EyeConeSights[conesSightStartIndex + i];
		inputOffset++;
	}

	// Temporals // @TODO
	// uint firstTemporalOutputIndex = (gid + 1) * uMaxNumOfNodesInBrain - numOfTemporals;

}
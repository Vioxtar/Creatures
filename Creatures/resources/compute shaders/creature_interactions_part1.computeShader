#version 460 core

layout (std430, binding = 0) buffer CreaturePositions
{
	vec2 Positions[];
};

layout (std430, binding = 1) buffer CreatureVelocities
{
	vec2 Velocities[];
};

layout (std430, binding = 2) buffer CreatureRadii
{
	float Radii[];
};

layout (std430, binding = 3) buffer CreatureMeats
{
	float Meats[];
};

layout (std430, binding = 4) buffer CreatureHardnesses
{
	float Hardnesses[];
};

layout (std430, binding = 5) buffer UniformGrid
{
	uint UGrid[];
};

layout (std430, binding = 6) buffer CreatureTiles
{
	int Tiles[];
};

layout (std430, binding = 7) buffer CreatureGeneralPurposeVec2
{
	vec2 PhysicsFixes[];
};

layout (std430, binding = 8) buffer CreatureCollidersCounts
{
	uint CollidersCounts[];
};

layout (std430, binding = 9) buffer CreatureCollidersIndices
{
	uint CollidersIndices[];
};

layout (std430, binding = 10) buffer CreatureCollidersToPosDirs
{
	vec2 CollidersToPosDirs[];
};

layout (std430, binding = 11) buffer CreatureCollidersPositions
{
	vec2 CollidersPositions[];
};

layout (std430, binding = 12) buffer CreatureCollidersRadii
{
	float CollidersRadii[];
};


layout (local_size_x = @LOCAL_SIZE@, local_size_y = 1, local_size_z = 1) in;


uniform uint uCreatureCount;
uniform uvec2 uGridDimensions;
uniform uint uIndicesInTile;
uniform uint uMaxNumOfColliders;
uniform vec2 uRandom;

void main()
{

	uint gid = gl_GlobalInvocationID.x;
	if (gid >= uCreatureCount)
	{
		return;
	}

	uint tileCreatureCapacity = uIndicesInTile - 1;

	uint gridXDim = uGridDimensions.x;
	uint gridYDim = uGridDimensions.y;	

	// Find our own tile
	int tileIndex = Tiles[gid];

	if (tileIndex == -1)
	{
		// If tile index is -1 then we were out of uniform grid bounds, do nothing
		return;
	}

	// Find its x,y tile indices
	uint xTileIndex = uint(mod(tileIndex, gridXDim));
	uint yTileIndex = (tileIndex - xTileIndex) / gridXDim;

	// Find the start/end x,y indices (consider uGridDimensions in case we're near edges)
	uint xStart = max(int(xTileIndex) - 1, 0);
	uint xEnd = min(xTileIndex + 1, gridXDim - 1);
	uint yStart = max(int(yTileIndex) - 1, 0);
	uint yEnd = min(yTileIndex + 1, gridYDim - 1);


	// Cache our own values, we don't need to access them every iteration
	vec2 aPos = Positions[gid];
	vec2 aVel = Velocities[gid];
	vec2 aOldPos = aPos - aVel;
	float aRad = Radii[gid];
	float aHardness = Hardnesses[gid];
	float aMeat = Meats[gid];

	uint aCollidersStartIndex = gid * uMaxNumOfColliders;
	
	// Iterate on the uniform grid throughout start/end x,y indices
	for (uint x = xStart; x <= xEnd; x++)
	{
		for (uint y = yStart; y <= yEnd; y++)
		{
			// Find the 1D tile again
			uint tile = x + gridXDim * y;
			
			// Iterate all other creatures currently in the tile
			uint tileCountIndex = tile * uIndicesInTile;
			uint creaturesInTile = min(UGrid[tileCountIndex], tileCreatureCapacity);
			uint lastPopulatedIndex = tileCountIndex + creaturesInTile;
							
			for (uint b = tileCountIndex + 1; b <= lastPopulatedIndex; b++)
			{

				uint bGID = UGrid[b];
				if (bGID >= uCreatureCount)
				{
					continue;
				}
			
				// Only the creature with the lesser GID performs the calculations
				if (bGID <= gid)
				{
					continue;
				}

				vec2 bPos = Positions[bGID];
				float bRad = Radii[bGID];
				float bMeat = Meats[bGID];

				vec2 c1c2PosDiff = bPos - aPos;
				float distSquared = dot(c1c2PosDiff, c1c2PosDiff);


				if (distSquared <= 0)
				{
					// Both creatures are inside each other, give each other a small push...
					PhysicsFixes[gid] += uRandom * aRad;
					PhysicsFixes[bGID] -= uRandom * bRad;
					continue; // @TODO: Continuing here is problematic because we're not registering colliders and stuff
				}

				float RadiiSum = aRad + bRad;
				if (distSquared < RadiiSum * RadiiSum)
				{
					
					/////////////////////////////
					// -- COLLISION PHYSICS -- //
					/////////////////////////////


					// Note on gliders: for easier computations, we don't check if creatures passed through each other (happens when
					// their velocities are bigger in magnitude than their radii). This is fine, however what we're not willing to have
					// are gliders: creature A is a glider when A passes through creature B, places itself on the OTHER side of creature B,
					// and gets a boost from it instead of slowing down, allowing A to glide through entire masses of creatures if it gets a
					// lucky placement. To midigate this, we perform a cheap solution:
					
					vec2 bVel = Velocities[bGID];
					vec2 bOldPos = bPos - bVel;
					vec2 c1c2OldPosDiff = bOldPos - aOldPos;
					if (dot(c1c2OldPosDiff, c1c2PosDiff) < 0.0) // Are we on the other side (did we pass the center point?)
					{
						// We over-penetrated (old positions placed each creature on each others' other side), fix to old position difference
						c1c2PosDiff = c1c2OldPosDiff;
					}
					
					// Proceed as usual...
				


					float dist = sqrt(distSquared);
					float violation = RadiiSum - dist;

					float bHardness = Hardnesses[bGID];
					float hardnessFactor = max(aHardness, bHardness);
					float penetrationPercentage = violation / RadiiSum;
					
					vec2 velDiff = aVel - bVel;
					float velCollideFactor = pow(dot(velDiff, velDiff), 0.25);
					float push = pow(hardnessFactor * velCollideFactor, 1.0 - penetrationPercentage) * violation;
			
					// @TODO: Place meat values here
					float m1 = 1;
					float m2 = 1;
					float m1Frac = m1 / (m1 + m2);
					float m2Frac = m2 / (m1 + m2);

					vec2 c1PosSub = -c1c2PosDiff * push * m2Frac;
					vec2 c2PosSub = c1c2PosDiff * push * m1Frac;
					
					// Register the physics collision fix
					PhysicsFixes[gid] += c1PosSub;
					PhysicsFixes[bGID] += c2PosSub;



					// Register colliders

					vec2 c1c2Dir = c1c2PosDiff / dist;
					vec2 c2c1Dir = -c1c2Dir;

					uint aCurrentCollidersCount = atomicAdd(CollidersCounts[gid], 1);
					if (aCurrentCollidersCount < uMaxNumOfColliders)
					{
						// We have enough room, add b to a
						uint colliderPlacementIndex = aCollidersStartIndex + aCurrentCollidersCount;

						CollidersIndices[colliderPlacementIndex] = bGID;
						CollidersToPosDirs[colliderPlacementIndex] = c2c1Dir;
						CollidersPositions[colliderPlacementIndex] = bPos;
						CollidersRadii[colliderPlacementIndex] = bRad;

					}


					uint bCollidersStartIndex = bGID * uMaxNumOfColliders;
					uint bCurrentCollidersCount = atomicAdd(CollidersCounts[bGID], 1);
					if (bCurrentCollidersCount < uMaxNumOfColliders)
					{
						// We have enough room, add a to b
						uint colliderPlacementIndex = bCollidersStartIndex + bCurrentCollidersCount;
						
						CollidersIndices[colliderPlacementIndex] = gid;
						CollidersToPosDirs[colliderPlacementIndex] = c1c2Dir;
						CollidersPositions[colliderPlacementIndex] = aPos;
						CollidersRadii[colliderPlacementIndex] = aRad;
					}
				}
			}
		}
	}

}
#version 460 core

// Per vertex values
in float oVertexSquaredDistance;
in float oForwardDirectionDot;
in float oSpikeDirectionDot;
in float oFeederDirectionDot;
in float oShieldDirectionDot;
in float oSpikeSquaredDistance;
in vec2 oEuclideanPos;

// Per instance values
// @TODO: Find if there's a way to pass these to the fragment shader actually per instance
in vec4 oVertexColor;
in vec2 oSkinPattern;
in float oLife;

out vec4 FragColor;
out float gl_FragDepth;

void main()
{
    
    // Display shading
    float shadingColMul = pow(1.0 - oVertexSquaredDistance, 0.25);

    // Display skin pattern
    float skinPatternColMul =
        mod(oVertexSquaredDistance, oSkinPattern.x) > oSkinPattern.y
        ? 1.1
        : 1.0;

    // Display forward direction
    float forwardDirColMul = 
        oForwardDirectionDot / oVertexSquaredDistance > 0.995 &&
        oVertexSquaredDistance > 0.35
        ? 1.35
        : 1.0;
   
    // Display shield
    float shieldSpan = 0.25;
    float shieldColMul =
        oShieldDirectionDot / oVertexSquaredDistance > (1.0 - shieldSpan) &&
        oVertexSquaredDistance > 0.75
        ? 1.25
        : 1.0;


    // Display spike
    float spikeColMul =
        oEuclideanPos.x > -0.5 && oEuclideanPos.x < 0.5
        ? 1.25
        : 1.0;

    
    // Set final color
    FragColor =
        oVertexColor *
        shadingColMul *
        skinPatternColMul *
        forwardDirColMul *
        //shieldColMul *
        spikeColMul;

    
    
    // Opaqueness reflects life
    FragColor.a = max(pow(oVertexSquaredDistance, (1.0 - oLife) * 5.0), oLife + 0.1);
    FragColor.a *= 0.975; // Still make everything ever so slightly transparent

    // May not be needed
    gl_FragDepth = oVertexSquaredDistance;
}
#version 460 core
layout (location = 0) in vec2 aPos;

layout (std430, binding = 0) buffer CreatureColors
{
	float Colors[];
};

layout (std430, binding = 1) buffer CreaturePositions
{
	vec2 Positions[];
};

layout (std430, binding = 2) buffer CreatureRadii
{
	float Radii[];
};

layout (std430, binding = 3) buffer CreatureLives
{
	float Lives[];
};

layout (std430, binding = 4) buffer CreatureSkinPatterns
{
	vec2 SkinPatterns[];
};

layout (std430, binding = 5) buffer CreatureDeformerPositions
{
	vec2 DeformerPositions[];
};

layout (std430, binding = 6) buffer CreatureDeformerRadii
{
	float DeformerRadii[];
};

layout (std430, binding = 7) buffer CreatureDeformerCounts
{
	uint DeformerCounts[];
};

out vec4 oVertexColor;
out float oVertexSquaredDistance;
out float oLife;
out vec2 oSkinPattern;

uniform mat4 uTransform;
uniform uint uMaxNumOfDeformers;


void main()
{
	vec2 pos = Positions[gl_InstanceID];
	float rad = Radii[gl_InstanceID];
	float life = Lives[gl_InstanceID];
	vec2 skin = SkinPatterns[gl_InstanceID];




	vec2 vertPos = pos + aPos * rad;
	
	// @TODO: Avoid using length every iteration, cull calculations if we're off screen

	// Iterate deformers to deform the mesh
	float pushBack = 0.0;
	uint deformersCount = min(DeformerCounts[gl_InstanceID], uMaxNumOfDeformers);
	uint deformersStartIndex = gl_InstanceID * uMaxNumOfDeformers;
	for (uint deformer = 0; deformer < deformersCount; deformer++)	{
		
		uint deformerIndex = deformersStartIndex + deformer;
		
		vec2 deformerPos = DeformerPositions[deformerIndex];
		float deformerRad = DeformerRadii[deformerIndex];

		vec2 deformerPosToVert = vertPos - deformerPos;
		float deformerPosToVertDistance = length(deformerPosToVert);

		vec2 posDiff = deformerPos - pos;
		
		// What is our violation?
		float violation = max(deformerRad - deformerPosToVertDistance, 0);
		
		float posDiffLength = deformerRad + rad - violation;

		// The new pushback value is the violation, multiplied by a dot factor; the closer we are to the posDiff direction,
		// the less we need be pushed back. This is a linear device used to approximate the result of an otherwise non-linear function
		float newPushback = violation * (1.0 - 0.5 * dot(posDiff / posDiffLength, aPos));
		pushBack = max(pushBack, newPushback);
	}

	vertPos -= aPos * pushBack;



	vec4 camTransformed = uTransform * vec4(vertPos.xy, 0.0, 1.0);
	gl_Position = camTransformed;

	// Vec3's are not supported by the std430 format, so we have to do this:
	uint colIndex = gl_InstanceID * 3;
	oVertexColor = vec4(Colors[colIndex], Colors[colIndex + 1], Colors[colIndex + 2], 1.0);

	oVertexSquaredDistance = dot(aPos, aPos);
	oSkinPattern = skin;
	oLife = life;
}
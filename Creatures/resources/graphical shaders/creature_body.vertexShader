#version 460 core
layout (location = 0) in vec2 aVertexLocalPos;

layout (std430, binding = 0) buffer CreatureColors
{
	float Colors[];
};

layout (std430, binding = 1) buffer CreaturePositions
{
	vec2 Positions[];
};

layout (std430, binding = 2) buffer CreatureForwardDirections
{
	vec2 ForwardDirections[];
};

layout (std430, binding = 3) buffer CreatureAngles
{
	float Angles[];
};

layout (std430, binding = 4) buffer CreatureRadii
{
	float Radii[];
};

layout (std430, binding = 5) buffer CreatureLives
{
	float Lives[];
};

layout (std430, binding = 6) buffer CreatureSkinPatterns
{
	vec2 SkinPatterns[];
};

layout (std430, binding = 7) buffer CreatureDeformerPositions
{
	vec2 DeformerPositions[];
};

layout (std430, binding = 8) buffer CreatureDeformerRadii
{
	float DeformerRadii[];
};

layout (std430, binding = 9) buffer CreatureDeformerCounts
{
	uint DeformerCounts[];
};


// Per vertex values
out float oVertexSquaredDistance;
out float oForwardDirectionDot;

// Per instance values
// @TODO: Find if there's a way to pass these to the fragment shader actually per instance
out vec4 oVertexColor;
out vec2 oSkinPattern;
out float oLife;

uniform mat4 uTransform;
uniform uint uMaxNumOfDeformers;

void main()
{
	uint colIndex = gl_InstanceID * 3;

	// Collect data
	vec2 creatureCenterPos = Positions[gl_InstanceID];
	float creatureRadius = Radii[gl_InstanceID];
	float creatureAngle = Angles[gl_InstanceID];
	float creatureLife = Lives[gl_InstanceID];
	vec2 creatureSkinPattern = SkinPatterns[gl_InstanceID];
	vec2 creatureForwardDir = ForwardDirections[gl_InstanceID];
	vec3 creatureColor = vec3(Colors[colIndex], Colors[colIndex + 1], Colors[colIndex + 2]);

	// Rotate by angle
	float cosAng = cos(creatureAngle);
	float sinAng = sin(creatureAngle);
	vec2 rotatedLocalVertPos = vec2(
		cosAng * aVertexLocalPos.x - sinAng * aVertexLocalPos.y,
		sinAng * aVertexLocalPos.x + cosAng * aVertexLocalPos.y
	);



	// Body deformations

	vec2 vertPos = creatureCenterPos + rotatedLocalVertPos * creatureRadius;
	
	// @TODO: Cull calculations if we're off screen

	// Iterate deformers to deform the mesh
	float pushBack = 0.0;
	uint deformersCount = min(DeformerCounts[gl_InstanceID], uMaxNumOfDeformers);
	uint deformersStartIndex = gl_InstanceID * uMaxNumOfDeformers;
	for (uint deformer = 0; deformer < deformersCount; deformer++)	{
		
		uint deformerIndex = deformersStartIndex + deformer;
		
		// Find our deformer's position and radius
		vec2 deformerPos = DeformerPositions[deformerIndex];
		float deformerRad = DeformerRadii[deformerIndex];

		vec2 deformerPosToVert = vertPos - deformerPos;
		float deformerPosToVertDistance = length(deformerPosToVert);
		vec2 creaturesPosDiff = deformerPos - creatureCenterPos;
		
		// Find the vertex violation
		float vertViolation = max(deformerRad - deformerPosToVertDistance, 0);
		
		// Find the length of the creatures' position difference, used for normalization without sqrt
		float creaturesPosDiffLength = deformerRad + creatureRadius - vertViolation;

		// The new pushback value is the violation, multiplied by a dot factor; the closer we are to the creaturesPosDiff direction,
		// the less we need be pushed back. This is a linear device used to approximate the result of an otherwise non-linear function
		float newPushback = vertViolation * (1.0 - 0.5 * dot(creaturesPosDiff / creaturesPosDiffLength, rotatedLocalVertPos));
		pushBack = max(pushBack, newPushback);
	}

	// Finalize this vertex's deformation
	vertPos -= rotatedLocalVertPos * pushBack;



	// Output values

	// Transform our vertex to camera space
	vec4 camTransformed = uTransform * vec4(vertPos.xy, 0.0, 1.0);
	gl_Position = camTransformed;

	// Per instance
	oVertexColor = vec4(creatureColor.xyz, 1.0);
	oSkinPattern = creatureSkinPattern;
	oLife = creatureLife;

	// Per vertex
	oVertexSquaredDistance = dot(rotatedLocalVertPos, rotatedLocalVertPos);
	oForwardDirectionDot = dot(rotatedLocalVertPos, creatureForwardDir);
}